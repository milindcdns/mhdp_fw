// SPDX-License-Identifier: GPL-2.0-only
/**
 * Cadence Display Port Xtensa Firmware
 *
 * Copyright (C) 2019 Cadence Design Systems 
 * 
 * http://www.cadence.com
 *
 ******************************************************************************
 *
 * utils.c
 *
 ******************************************************************************
 */

#include "utils.h"
#include "stdlib.h"
#include "aes.h"
#include "sha.h"
#include "reg.h"
#include "static_alloc.h"

bool if_buffers_equal(const uint8_t* const a, const uint8_t* const b, uint32_t size)
{
    bool result = true;

    if (memcmp(a, b, size) != 0) {
        result = false;
    }

    return result;
}

/**
 * Swap order of items in buff.
 * @param[in,out] buff, pointer to buffer with items to swap.
 * @param[in] size [in], number of elements in buffer.
 */
void convertEndianness(uint8_t *buff, size_t size)
{	uint8_t temp; // temporary value to store a byte while switching
    size_t a = 0U;
    size_t b = size - 1U;

    while (a < b) {
        temp = buff[a];
        buff[a] = buff[b];
        buff[b] = temp;
        a++;
        b--;
    }
}

/** Allocate memory using static_alloc.h */
uint32_t* MEM_malloc(uint16_t size) {
    return malloc_static_ptr32(size);
}

/** Free memory using static_alloc.h */
void MEM_free(const uint32_t *ptr) {
    free_static_ptr32(ptr);
}

/* These arrays serve different purpose, only the initialization values are the same. */
static uint32_t seed[4] = {0U, 1U, 2U, 3U};
static uint32_t KEY[4] = {0U, 1U, 2U, 3U};

static uint32_t UTIL_TRNG_Get16BitNum(uint32_t inVal) {
    uint8_t i;
    uint32_t res = 0;
    uint32_t inValCopy = inVal; // this is to avoid modification of an argument
    for (i = 0; i < 16U; i++) {
        res = res ^ (inValCopy & 1U); // last bit XOR
        inValCopy = inValCopy >> 1;
    }
    return res;
}

/* Set seed for Pseudo Random Number Generator */
void UTIL_PRNG_SetSeed(const uint32_t* seedVal) {
    uint8_t i;
    for (i = 0; i < 4U; i++) {
        seed[i] = seedVal[i];
        KEY[i] = seedVal[i + 4U];
    }
}

/* Perform a XOR bitwise operation on every element of input_1 and input_2 arrays
 * and save under output array. */
static void xor_every_array_element(const uint32_t input_1[], const uint32_t input_2[],
        uint32_t output[], uint8_t number_of_elements) {
    uint8_t i;
    for (i = 0; i < number_of_elements; i++) {
        output[i] = input_1[i] ^ input_2[i];
    }
}

/** get 128 bit of random bits */
static void UTIL_PRNG_get128BitRandomData(uint32_t randomData[4]) {
    uint32_t secondAesInput[4], I_table[4];
    static uint64_t counter = 0;
    // set data for first AES
    uint32_t DT[4] = { GetDword0(counter), GetDword1(counter + 1U), GetDword0(counter + 1U),
            GetDword1(counter + 1U) };
    counter++;
    aes_setkey((const uint8_t *) KEY);

    aes_crypt((uint8_t *)DT,  (uint8_t *)I_table);
    // XOR I_table and seed and save to secondAesInput
    xor_every_array_element(I_table, seed, secondAesInput, 4U);

    aes_crypt((uint8_t *)secondAesInput, (uint8_t *)randomData);
    // XOR I_table and randomData and save to secondAesInput
    xor_every_array_element(I_table, randomData, secondAesInput, 4U);

    aes_crypt((uint8_t *)secondAesInput, (uint8_t *)seed);
}

/**
 * Fill the buffer with random numbers. Numbers are generated by Pseudo Random Number Generator.
 * @param[in] len_bytes, number of bytes to write (with 4 bytes granularity)
 * @param[in,out] buff, buffer that needs to be filled
 */
void UTIL_FillRandomNumber(uint8_t * buff, uint8_t lenBytes) {
    uint32_t iByteCnt, jDwordCnt;
    uint32_t randomDwordData[4];
    uint32_t startingLenByte = 0;
    while (startingLenByte < lenBytes) {
        UTIL_PRNG_get128BitRandomData(randomDwordData);
        // we have 16 bytes / 4 dwords of random data prepared
        jDwordCnt = 0;
        for (iByteCnt = startingLenByte + 0U; iByteCnt < (startingLenByte + 16U); iByteCnt += 4U) {
            if (iByteCnt >= lenBytes) {
                break;
            }
            setLe32(randomDwordData[jDwordCnt], &buff[iByteCnt]);
            jDwordCnt++;
        }
        startingLenByte += 16U;
    }
}
